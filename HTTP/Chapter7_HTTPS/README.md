## 7.1 HTTP의 약점

- 평문(암호화 하지 않은) 통신이기 때문에 도청 가능

- 통신 상대를 확인하지 않기 때문에 위장 가능

- 완전성을 증명할 수 없기 때문에 변조 가능

### 7.1.1 평문이기 때문에 도청 가능

- HTTP는 자신을 암호화하는 기능은 없기 때문에 통신 전체가 암호화 되지 않는다.

- TCP/IP는 도청 가능한 네트워크

- 암호화로 도청 회픠

  - 통신 암호화

    - 안전한 통신로를 확립 후 통신을 개시한다.

    - SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다.

    - HTTPS: SSL을 조합한 HTTP

  - 콘텐츠 암호화

    - 통신하고 있는 콘텐츠의 내용 자체를 암호화

    - 클라이언트에서 HTTP 메세지를 암호화해서 출력하는 처리가 필요

<br>

### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능

- HTTP를 사용한 리퀘스트/리스폰스 시 통신 상대를 확인하지 않는다.

- 리퀘스트를 보내는 상대가 누구든지 리스폰스를 반환한다.

- 상대를 확인하는 증명서

  - SSL은 암호화뿐 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다.

  - 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.

  - 증명서 위조는 기술적으로 상당히 어렵다.

  - 클라이언트가 증명서를 가짐으로써 본인을 확인을 하고, 웹 사이트 인증에서 이용할 수도 있다.

<br>

### 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능

- `완전성 == 정보의 정확성`

- `그것을 증명할 수 없다 == 정보가 정확한지 아닌지를 확인할 수 없다`

- 수신한 내용이 다를지도 모른다.

  - 발신된 리퀘스트나 리스폰스와 수신한 리퀘스트나 리스폰스가 같은지 아닌지를 확인할 수 없다.

- 중간자 공격(Man in the Middle)
  - 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격

<br>

### 변조를 방지하려면?

- MD5나 SHA-1 등의 해시 값을 확인하거나 파일의 디지털 서명을 확인

<br>

## 7.2 HTTP + 암화화 + 인증 + 완전성 보호 = HTTPS

### 7.2.1 HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS

- HTTPS

  - HTTP Secure

  - HTTP에 암호화나 인증 등의 구조를 더한 것

- 주로 로그인이나 쇼핑의 결제 화면 등에 사용

<br>

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP

- HTTP 통신을 하는 소켓 부분을 SSL이나 TLS이라는 프로토콜로 대체

- SSL 사용시 HTTP는 SSL과 통신하고 SSL이 TCP와 통신

<br>

### 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식

- 공통키 암호

  - 암호화와 복호화에 하나의 키를 같이 사용하는 방식

  - 이는 상대방에서 키를넘겨주지 않으면 안된다.

  - 네트워크를 사용해 키를 넘겨줄 떄 키를 빼앗기게 되면 암호화의 의미가 없게 된다.

- 공걔키 암호

  - 서로 다른 두 개의 키 페어를 사용

  - 한쪽은 비밀키라 부르고 다른 한쪽은 공개키라고 부른다.

  - 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 한다.

  - 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화한다.

  - 암호를 푸는 비밀키를 통신으로 보낼 필요가 없어 도청에 의해 키를 빼앗길 걱정이 없다.

  - 다만 처리 속도는 공통키 암호보다 느리다.

- HTTPS는 하이브리드 암호 시스템

  - 키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용한다.

<br>

### 7.2.4 공개키가 정확한지 아닌지를 증명하는 증명서

- 공개키 문제점

  - 공개키가 진짜인지 아닌지를 증명할 수 없다.

- 해결책

  - 인증 기관(CA: Certificate Authority)과 그 기관이 발행하는 공개키 증명서를 이용

  - 인증 기관 : 클라이언트와 서버가 모두 신뢰하는 제3자 기관 ex) VeriSign

- 인증 기관 이용 과정

  1. 서버의 운영자가 인증 기관에 공개키를 제출

  2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듦.

  3. 공개키 인증서에 서명이 끝난 공개키를 담음.

  4. 서버는 이 인증 기관에 의해서 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신을 함.

  5. 서버의 비밀키로 메시지를 복호화

<br>

### 조직의 실제성을 증명하는 EV SSL 증명서

- 증명서의 역할

  - 서버가 올바른 통신 상대임을 증명

  - **상대방이 실제로 있는 기업인지를 확인**  
    -> EV SSL

- 브라우저의 주소창의 색이 녹색으로 변함 -> EV SSL 증명서로 증명된 웹 사이트

<br>

### 클라이언트를 확인하는 클라이언트 증명서

- 서버 증명서와 같이 서버가 통신하고 있는 상대가 의도한 클라이언트인 것을 증명하는 클라이언트 인증을 할 수 있다.

<br>

### 자기 인증 기관 발행 증명서

- 자기 인증 기관

  - 독자적으로 구축한 인증 기관이기 때문에 쓸모없다.

- OpenSSL 사용시 누구든 인증 기관 구축이 가능하다.

<br>

### 7.2.5 안전한 통신을 하는 HTTPS의 구조

1. 클라가 Client Hello 메세지를 송신하면서 SSL 통신 시작한다.

- 클라가 제공하는 SSL의 버전을 지정
- 암호 스위트로 불리는 리스트 (사용하는 암호화의 알고리즘이나 키 사이즈 등을 포함)

2. 서버가 SSL 통신 가능한 경우 Server Hello 메시지로 응답

- SSL 버전
- 암호 스위트

3. 서버가 Certificate 메세지를 송신

- 공개키 증명서

4. 서버가 Server Hello Done 메시지를 송신

- 최초의 네고시에이션 부분이 끝났음을 통지

5. SSL의 최초 네고시에이션 종료 -> 클라가 Client Key Exchange 메시지로 응답

- Pre-Master secret (통신을 암호화하는데 사용)
- 이 메세지는 '3.'의 공개키 증명서에서 꺼낸 공개키로 암호화되어 있음

6. 클라는 Change Cipher Spec 메시지를 송신

- 이 메시지 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타낸다.

7. 클라는 Finished 메시지를 송신

- 접속 전체의 체크 값을 포함
- 네고시에이션 성공 유무는 서버의 복호화 가능 여부를 결정

8. 서버에서도 Change Cipher Spec 메시지 송신

9. 서버에서도 Finished 메시지 송신

10. Finished 메시지 교환 완료시 SSL에 의해서 접속 확립

11. 이후 HTTP 리퀴스트를 송신

12. 마지막에 클라가 접속을 끊는다.

- close_notify 메시지를 송신
- TCP FIN 메시지를 보내 TCP 통신 종료

<br>

### HTTPS 문제 - 통신 지연

- 통신 속도 저하

- 리소스 다량 소모 -> 처리 속도 저하
